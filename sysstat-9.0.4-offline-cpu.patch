diff -upr sysstat-9.0.4.old/man/mpstat.1 sysstat-9.0.4/man/mpstat.1
--- sysstat-9.0.4.old/man/mpstat.1	2009-05-22 15:36:04.000000000 +0200
+++ sysstat-9.0.4/man/mpstat.1	2012-02-21 11:24:52.414737021 +0100
@@ -4,7 +4,7 @@ mpstat \- Report processors related stat
 .SH SYNOPSIS
 .B mpstat [ -A ] [ -I { SUM | CPU | ALL } ] [ -u ] [ -P {
 .I cpu
-.B [,...] | ALL } ] [ -V ] [
+.B [,...] | ON | ALL } ] [ -V ] [
 .I interval
 .B [
 .I count
@@ -82,11 +82,14 @@ keyword is equivalent to specifying all 
 therefore all the interrupts statistics are displayed.
 .RE
 .RE
-.IP "-P { cpu [,...] | ALL }"
+.IP "-P { cpu [,...] | ON | ALL }"
 Indicate the processor number for which statistics are to be reported.
 .I cpu
 is the processor number. Note that processor 0 is the first processor.
 The
+.B ON
+keyword indicates that statistics are to be reported for every
+online processor, whereas the
 .B ALL
 keyword indicates that statistics are to be reported for all processors.
 .IP -u
diff -upr sysstat-9.0.4.old/mpstat.c sysstat-9.0.4/mpstat.c
--- sysstat-9.0.4.old/mpstat.c	2012-02-21 11:21:01.000000000 +0100
+++ sysstat-9.0.4/mpstat.c	2012-02-21 11:21:39.481791187 +0100
@@ -84,7 +84,8 @@ void usage(char *progname)
 		progname);
 
 	fprintf(stderr, _("Options are:\n"
-			  "[ -A ] [ -I { SUM | CPU | ALL } ] [ -u ] [ -P { <cpu> [,...] | ALL } ] [ -V ]\n"));
+			  "[ -A ] [ -I { SUM | CPU | ALL } ] [ -u ]\n"
+			  "[ -P { <cpu> [,...] | ON | ALL } ] [ -V ]\n"));
 	exit(1);
 }
 
@@ -176,7 +177,132 @@ void sfree_mp_struct(void)
 
 /*
  ***************************************************************************
- * Core function used to display statistics
+ * Display per CPU statistics.
+ *
+ * IN:
+ * @st_ic	Array for per-CPU statistics.
+ * @ic_nr	Number of interrupts per CPU.
+ * @dis		TRUE if a header line must be printed.
+ * @itv		Interval value.
+ * @prev	Position in array where statistics used	as reference are.
+ *		Stats used as reference may be the previous ones read, or
+ *		the very first ones when calculating the average.
+ * @curr	Position in array where current statistics will be saved.
+ * @prev_string	String displayed at the beginning of a header line. This is
+ * 		the timestamp of the previous sample, or "Average" when
+ * 		displaying average stats.
+ * @curr_string	String displayed at the beginning of current sample stats.
+ * 		This is the timestamp of the current sample, or "Average"
+ * 		when displaying average stats.
+ ***************************************************************************
+ */
+void write_irqcpu_stats(struct stats_irqcpu *st_ic[], int ic_nr, int dis,
+			unsigned long long itv, int prev, int curr,
+			char *prev_string, char *curr_string)
+{
+	struct stats_cpu *scc, *scp;
+	int j = 0, offset, cpu;
+	struct stats_irqcpu *p, *q, *p0, *q0;
+
+	/*
+	* Check if number of interrupts has changed.
+	* NB: A null interval value indicates that we are
+	 * displaying statistics since system startup.
+	 */
+	if (!dis && interval) {
+		do {
+			p0 = st_ic[curr] + j;
+			if (p0->irq[0] != '\0') {
+				q0 = st_ic[prev] + j;
+				if (strcmp(p0->irq, q0->irq)) {
+					/* These are two different irq */
+					j = -2;
+				}
+			}
+			j++;
+		}
+		while ((j > 0) && (j <= ic_nr));
+	}
+
+	if (dis || (j < 0)) {
+		/* Print header */
+		printf("\n%-11s  CPU", prev_string);
+		for (j = 0; j < ic_nr; j++) {
+			p0 = st_ic[curr] + j;
+			if (p0->irq[0] != '\0') {	/* Nb of irq per proc may have varied... */
+				printf(" %8s/s", p0->irq);
+			}
+		}
+		printf("\n");
+	}
+
+	for (cpu = 1; cpu <= cpu_nr; cpu++) {
+
+		scc = st_cpu[curr] + cpu;
+		scp = st_cpu[prev] + cpu;
+
+		/*
+		 * Check if we want stats about this CPU.
+		 * CPU must have been explicitly selected using option -P,
+		 * else we display every CPU.
+		 */
+		if (!(*(cpu_bitmap + (cpu >> 3)) & (1 << (cpu & 0x07))) && USE_P_OPTION(flags))
+			continue;
+
+		if ((scc->cpu_user    + scc->cpu_nice + scc->cpu_sys   +
+		     scc->cpu_iowait  + scc->cpu_idle + scc->cpu_steal +
+		     scc->cpu_hardirq + scc->cpu_softirq) == 0) {
+
+			/* Offline CPU found */
+
+			if (DISPLAY_ONLINE_CPU(flags))
+				continue;
+		}
+
+		printf("%-11s  %3d", curr_string, cpu - 1);
+
+		for (j = 0; j < ic_nr; j++) {
+			p0 = st_ic[curr] + j;	/* irq field set only for proc #0 */
+			/*
+			 * An empty string for irq name means it is a remaining interrupt
+			 * which is no longer used, for example because the
+			 * number of interrupts has decreased in /proc/interrupts.
+			 */
+			if (p0->irq[0] != '\0') {
+				q0 = st_ic[prev] + j;
+				offset = j;
+
+				/*
+				 * If we want stats for the time since system startup,
+				 * we have p0->irq != q0->irq, since q0 structure is
+				 * completely set to zero.
+				 */
+				if (strcmp(p0->irq, q0->irq) && interval) {
+					if (j)
+						offset = j - 1;
+					q0 = st_ic[prev] + offset;
+					if (strcmp(p0->irq, q0->irq) && (j + 1 < ic_nr))
+						offset = j + 1;
+					q0 = st_ic[prev] + offset;
+				}
+
+				if (!strcmp(p0->irq, q0->irq) || !interval) {
+					p = st_ic[curr] + (cpu - 1) * ic_nr + j;
+					q = st_ic[prev] + (cpu - 1) * ic_nr + offset;
+					printf(" %10.2f",
+					       S_VALUE(q->interrupt, p->interrupt, itv));
+				}
+				else
+					printf("        N/A");
+			}
+		}
+		printf("\n");
+	}
+}
+
+/*
+ ***************************************************************************
+ * Core function used to display statistics.
  *
  * IN:
  * @prev	Position in array where statistics used	as reference are.
@@ -227,6 +353,9 @@ void write_stats_core(int prev, int curr
 			printf("%-11s  all", curr_string);
 
 			printf("  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f\n",
+			       (st_cpu[curr]->cpu_user - st_cpu[curr]->cpu_guest) <
+			       (st_cpu[prev]->cpu_user - st_cpu[prev]->cpu_guest) ?
+			       0.0 :
 			       ll_sp_value(st_cpu[prev]->cpu_user - st_cpu[prev]->cpu_guest,
 					   st_cpu[curr]->cpu_user - st_cpu[curr]->cpu_guest,
 					   g_itv),
@@ -266,31 +395,41 @@ void write_stats_core(int prev, int curr
 			/* Check if we want stats about this proc */
 			if (!(*(cpu_bitmap + (cpu >> 3)) & (1 << (cpu & 0x07))))
 				continue;
+			
+			/*
+			 * If the CPU is offline then it is omited from /proc/stat
+			 * and the sum of all values is zero.
+			 * (Remember that guest time is already included in user mode.)
+			 */
+			if ((scc->cpu_user    + scc->cpu_nice + scc->cpu_sys   +
+			     scc->cpu_iowait  + scc->cpu_idle + scc->cpu_steal +
+			     scc->cpu_hardirq + scc->cpu_softirq) == 0) {
+
+				if (!DISPLAY_ONLINE_CPU(flags)) {
+					printf("%-11s %4d"
+					       "  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f"
+					       "  %6.2f  %6.2f  %6.2f\n",
+					       curr_string, cpu - 1,
+					       0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+				}
+				continue;
+			}
 
 			printf("%-11s %4d", curr_string, cpu - 1);
 
 			/* Recalculate itv for current proc */
 			pc_itv = get_per_cpu_interval(scc, scp);
-			if ((scc->cpu_user - scc->cpu_guest) < (scp->cpu_user - scp->cpu_guest))
-				pc_itv = pc_itv + (scp->cpu_user - scp->cpu_guest) - 
-					(scc->cpu_user - scc->cpu_guest);
-
-			/* if the CPU is offline it is omited from /proc/stat
-			   so the sum of all values is zero */
-			if ((scc->cpu_user    + scc->cpu_nice   + scc->cpu_sys   +
-			     scc->cpu_iowait  + scc->cpu_idle   + scc->cpu_steal +
-			     scc->cpu_hardirq + scc->cpu_softirq) == 0) {
-				printf("    0.00    0.00    0.00    0.00    0.00    0.00"
-				       "    0.00    0.00    0.00\n");
-				continue;
-			}
-
-			/* if the CPU is tickless  then
-			  there is no change in CPU values but the sum of values is not null */
+			
 			if (!pc_itv) {
-				printf("    0.00    0.00    0.00    0.00    0.00    0.00"
-				       "    0.00    0.00  100.00\n");
+				/*
+				 * If the CPU is tickless then there is no change in CPU values
+				 * but the sum of values is not zero.
+				 */
+				printf("  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f"
+				       "  %6.2f  %6.2f  %6.2f\n",
+				       0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 100.0);
 			}
+
 			else {
 				printf("  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f"
 				       "  %6.2f  %6.2f  %6.2f\n",
@@ -354,14 +493,29 @@ void write_stats_core(int prev, int curr
 			if (!(*(cpu_bitmap + (cpu >> 3)) & (1 << (cpu & 0x07))))
 				continue;
 
+			if ((scc->cpu_user    + scc->cpu_nice + scc->cpu_sys   +
+			     scc->cpu_iowait  + scc->cpu_idle + scc->cpu_steal +
+			     scc->cpu_hardirq + scc->cpu_softirq) == 0) {
+
+				/* This is an offline CPU */
+				
+				if (!DISPLAY_ONLINE_CPU(flags)) {
+					printf("%-11s %4d"
+					       "  %9.2f\n",
+					       curr_string, cpu - 1,
+					       0.0);
+				}
+				continue;
+			}
+
 			printf("%-11s %4d", curr_string, cpu - 1);
 
 			/* Recalculate itv for current proc */
 			pc_itv = get_per_cpu_interval(scc, scp);
 
 			if (!pc_itv) {
-				/* Current CPU is offline */
-				printf("    0.00\n");
+				/* This is a tickless CPU */
+				printf(" %9.2f\n", 0.0);
 			}
 			else {
 				printf(" %9.2f\n",
@@ -371,88 +525,26 @@ void write_stats_core(int prev, int curr
 	}
 
 	if (DISPLAY_IRQ_CPU(actflags)) {
-		int j = 0, offset;
-		struct stats_irqcpu *p, *q, *p0, *q0;
-
-		/*
-		 * Check if number of interrupts has changed.
-		 * NB: A null interval value indicates that we are
-		 * displaying statistics since system startup.
-		 */
-		if (!dis && interval) {
-			do {
-				p0 = st_irqcpu[curr] + j;
-				if (p0->irq[0] != '\0') {
-					q0 = st_irqcpu[prev] + j;
-					if (strcmp(p0->irq, q0->irq)) {
-						/* These are two different irq */
-						j = -2;
-					}
-				}
-				j++;
-			}
-			while ((j > 0) && (j <= irqcpu_nr));
-		}
+		write_irqcpu_stats(st_irqcpu, irqcpu_nr, dis, itv, prev, curr,
+				   prev_string, curr_string);
+	}
 
-		if (dis || (j < 0)) {
-			/* Print header */
-			printf("\n%-11s  CPU", prev_string);
-			for (j = 0; j < irqcpu_nr; j++) {
-				p0 = st_irqcpu[curr] + j;
-				if (p0->irq[0] != '\0') {	/* Nb of irq per proc may have varied... */
-					printf(" %5s/s", p0->irq);
-				}
-			}
-			printf("\n");
-		}
+	/* Fix CPU counter values for every offline CPU */
+	for (cpu = 1; cpu <= cpu_nr; cpu++) {
 
-		for (cpu = 1; cpu <= cpu_nr; cpu++) {
+		scc = st_cpu[curr] + cpu;
+		scp = st_cpu[prev] + cpu;
 
+		if ((scc->cpu_user    + scc->cpu_nice + scc->cpu_sys   +
+		     scc->cpu_iowait  + scc->cpu_idle + scc->cpu_steal +
+		     scc->cpu_hardirq + scc->cpu_softirq) == 0) {
 			/*
-			 * Check if we want stats about this CPU.
-			 * CPU must have been explicitly selected using option -P,
-			 * else we display every CPU.
+			 * Offline CPU found.
+			 * Set current struct fields (which have been set to zero)
+			 * to values from previous iteration. Hence their values won't
+			 * jump from zero when the CPU comes back online.
 			 */
-			if (!(*(cpu_bitmap + (cpu >> 3)) & (1 << (cpu & 0x07))) && USE_P_OPTION(flags))
-				continue;
-
-			printf("%-11s  %3d", curr_string, cpu - 1);
-
-			for (j = 0; j < irqcpu_nr; j++) {
-				p0 = st_irqcpu[curr] + j;	/* irq field set only for proc #0 */
-				/*
-				 * An empty string for irq name means it is a remaining interrupt
-				 * which is no longer used, for example because the
-				 * number of interrupts has decreased in /proc/interrupts.
-				 */
-				if (p0->irq[0] != '\0') {
-					q0 = st_irqcpu[prev] + j;
-					offset = j;
-
-					/*
-					 * If we want stats for the time since system startup,
-					 * we have p0->irq != q0->irq, since q0 structure is
-					 * completely set to zero.
-					 */
-					if (strcmp(p0->irq, q0->irq) && interval) {
-						if (j)
-							offset = j - 1;
-						q0 = st_irqcpu[prev] + offset;
-						if (strcmp(p0->irq, q0->irq) && (j + 1 < irqcpu_nr))
-							offset = j + 1;
-						q0 = st_irqcpu[prev] + offset;
-					}
-					if (!strcmp(p0->irq, q0->irq) || !interval) {
-						p = st_irqcpu[curr] + (cpu - 1) * irqcpu_nr + j;
-						q = st_irqcpu[prev] + (cpu - 1) * irqcpu_nr + offset;
-						printf(" %7.2f",
-						       S_VALUE(q->interrupt, p->interrupt, itv));
-					}
-					else
-						printf("     N/A");
-				}
-			}
-			printf("\n");
+			*scc = *scp;
 		}
 	}
 }
@@ -652,21 +744,13 @@ void rw_mpstat_loop(int dis_hdr, int row
 	do {
 		/*
 		 * Resetting the structure not needed since every fields will be set.
-		 * Exceptions are per-CPU structures: some of them may not be filled
-		 * if corresponding processor is disabled (offline).
+		 * Exceptions are per-CPU structures: Some of them may not be filled
+		 * if corresponding processor is disabled (offline). We set them to zero
+		 * to be able to distinguish between offline and tickless CPUs.
 		 */
 		for (cpu = 1; cpu <= cpu_nr; cpu++) {
-			scc = st_cpu[curr]  + cpu;
-			scp = st_cpu[!curr] + cpu;
-			*scc = *scp;
-			scc->cpu_user = 0;
-			scc->cpu_nice = 0;
-			scc->cpu_sys = 0;
-			scc->cpu_iowait = 0;
-			scc->cpu_idle = 0;
-			scc->cpu_steal = 0;
-			scc->cpu_hardirq = 0;
-			scc->cpu_softirq = 0;
+			scc = st_cpu[curr] + cpu;
+			memset(scc, 0, STATS_CPU_SIZE);
 		}
 
 		/* Get time */
@@ -718,7 +802,7 @@ void rw_mpstat_loop(int dis_hdr, int row
  */
 int main(int argc, char **argv)
 {
-	int opt = 0, i;
+	int opt = 0, i, actset = FALSE;
 	struct utsname header;
 	int dis_hdr = -1;
 	int rows = 23;
@@ -734,6 +818,7 @@ int main(int argc, char **argv)
 
 	/* How many processors on this machine ? */
 	cpu_nr = get_cpu_nr(~0);
+	
 	/* Calculate number of interrupts per processor */
 	irqcpu_nr = get_irqcpu_nr(NR_IRQS, cpu_nr) + NR_IRQCPU_PREALLOC;
 
@@ -747,6 +832,7 @@ int main(int argc, char **argv)
 
 		if (!strcmp(argv[opt], "-I")) {
 			if (argv[++opt]) {
+				actset = TRUE;
 				if (!strcmp(argv[opt], K_SUM)) {
 					/* Display total number of interrupts per CPU */
 					actflags |= M_D_IRQ_SUM;
@@ -774,7 +860,7 @@ int main(int argc, char **argv)
 				dis_hdr++;
 				
 				for (t = strtok(argv[opt], ","); t; t = strtok(NULL, ",")) {
-					if (!strcmp(t, K_ALL)) {
+					if (!strcmp(t, K_ALL) || !strcmp(t, K_ON)) {
 						if (cpu_nr) {
 							dis_hdr = 9;
 						}
@@ -783,6 +869,10 @@ int main(int argc, char **argv)
 						 * Also indicate to display stats for CPU 'all'.
 						 */
 						memset(cpu_bitmap, 0xff, ((cpu_nr + 1) >> 3) + 1);
+						if (!strcmp(t, K_ON)) {
+							/* Display stats only for online CPU */
+							flags |= F_P_ON;
+						}
 					}
 					else {
 						if (strspn(t, DIGITS) != strlen(t)) {
@@ -810,11 +900,12 @@ int main(int argc, char **argv)
 
 				case 'A':
 					actflags |= M_D_CPU + M_D_IRQ_SUM + M_D_IRQ_CPU;
+					actset = TRUE;
 					/* Select all processors */
 					flags |= F_P_OPTION;
 					memset(cpu_bitmap, 0xff, ((cpu_nr + 1) >> 3) + 1);
 					break;
-
+					
 				case 'u':
 					/* Display CPU */
 					actflags |= M_D_CPU;
@@ -861,7 +952,7 @@ int main(int argc, char **argv)
 	}
 
 	/* Default: Display CPU */
-	if (!DISPLAY_CPU(actflags) && !DISPLAY_IRQ_SUM(actflags) && !DISPLAY_IRQ_CPU(actflags)) {
+	if (!actset) {
 		actflags |= M_D_CPU;
 	}
 
diff -upr sysstat-9.0.4.old/mpstat.h sysstat-9.0.4/mpstat.h
--- sysstat-9.0.4.old/mpstat.h	2009-07-18 15:19:57.000000000 +0200
+++ sysstat-9.0.4/mpstat.h	2012-02-21 11:21:39.481791187 +0100
@@ -30,15 +30,20 @@
 
 /* Indicate that option -P has been used */
 #define F_P_OPTION	0x01
+/* Indicate that stats should be displayed on for online CPU ("-P ON") */
+#define F_P_ON		0x02
 
-#define USE_P_OPTION(m)	(((m) & F_P_OPTION) == F_P_OPTION)
+#define USE_P_OPTION(m)		(((m) & F_P_OPTION) == F_P_OPTION)
+#define DISPLAY_ONLINE_CPU(m)	(((m) & F_P_ON) == F_P_ON)
 
 #define K_SUM	"SUM"
 #define K_CPU	"CPU"
+#define K_SCPU	"SCPU"
+#define K_ON	"ON"
 
 #define NR_IRQCPU_PREALLOC	3
 
-#define MAX_IRQ_LEN		8
+#define MAX_IRQ_LEN		16
 
 /*
  ***************************************************************************
