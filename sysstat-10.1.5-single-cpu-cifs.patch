diff -upr sysstat-10.1.5.orig/cifsiostat.c sysstat-10.1.5/cifsiostat.c
--- sysstat-10.1.5.orig/cifsiostat.c	2013-03-23 17:31:46.000000000 +0100
+++ sysstat-10.1.5/cifsiostat.c	2014-09-29 14:23:37.600574444 +0200
@@ -43,7 +43,6 @@
 #define SCCSID "@(#)sysstat-" VERSION ": " __FILE__ " compiled " __DATE__ " " __TIME__
 char *sccsid(void) { return (SCCSID); }
 
-unsigned long long uptime[2]  = {0, 0};
 unsigned long long uptime0[2] = {0, 0};
 struct cifs_stats *st_cifs[2];
 struct io_hdr_stats *st_hdr_cifs;
@@ -474,13 +473,8 @@ void write_stats(int curr, struct tm *re
 #endif
 	}
 
-	/* Interval is multiplied by the number of processors */
-	itv = get_interval(uptime[!curr], uptime[curr]);
-
-	if (cpu_nr > 1) {
-		/* On SMP machines, reduce itv to one processor (see note above) */
-		itv = get_interval(uptime0[!curr], uptime0[curr]);
-	}
+	/* Interval of time, reduced to one processor */
+	itv = get_interval(uptime0[!curr], uptime0[curr]);
 
 	shi = st_hdr_cifs;
 
@@ -527,15 +521,12 @@ void rw_io_stat_loop(long int count, str
 	setbuf(stdout, NULL);
 	
 	do {
-		if (cpu_nr > 1) {
-			/*
-			 * Read system uptime (only for SMP machines).
-			 * Init uptime0. So if /proc/uptime cannot fill it,
-			 * this will be done by /proc/stat.
-			 */
-			uptime0[curr] = 0;
-			read_uptime(&(uptime0[curr]));
-		}
+		/* Read system uptime (reduced to one processor) */
+		uptime0[curr] = 0;
+		read_uptime(&(uptime0[curr]));
+		if (!uptime0[curr])
+			/* Cannot read system uptime (/proc/uptime doesn't exist) */
+			exit(2);
 
 		/* Read CIFS stats */
 		read_cifs_stat(curr);
diff -upr sysstat-10.1.5.orig/nfsiostat.c sysstat-10.1.5/nfsiostat.c
--- sysstat-10.1.5.orig/nfsiostat.c	2013-03-23 17:31:46.000000000 +0100
+++ sysstat-10.1.5/nfsiostat.c	2014-09-29 14:23:37.601574440 +0200
@@ -42,7 +42,6 @@
 #define SCCSID "@(#)sysstat-" VERSION ": " __FILE__ " compiled " __DATE__ " " __TIME__
 char *sccsid(void) { return (SCCSID); }
 
-unsigned long long uptime[2]  = {0, 0};
 unsigned long long uptime0[2] = {0, 0};
 struct io_nfs_stats *st_ionfs[2];
 struct io_hdr_stats *st_hdr_ionfs;
@@ -541,13 +540,8 @@ void write_stats(int curr, struct tm *re
 #endif
 	}
 
-	/* Interval is multiplied by the number of processors */
-	itv = get_interval(uptime[!curr], uptime[curr]);
-
-	if (cpu_nr > 1) {
-		/* On SMP machines, reduce itv to one processor (see note above) */
-		itv = get_interval(uptime0[!curr], uptime0[curr]);
-	}
+	/* Interval of time, reduced to one processor */
+	itv = get_interval(uptime0[!curr], uptime0[curr]);
 
 	shi = st_hdr_ionfs;
 
@@ -595,15 +589,13 @@ void rw_io_stat_loop(long int count, str
 	setbuf(stdout, NULL);
 	
 	do {
-		if (cpu_nr > 1) {
-			/*
-			 * Read system uptime (only for SMP machines).
-			 * Init uptime0. So if /proc/uptime cannot fill it,
-			 * this will be done by /proc/stat.
-			 */
-			uptime0[curr] = 0;
-			read_uptime(&(uptime0[curr]));
-		}
+		/* Read system uptime (reduced to one processor) */
+		uptime0[curr] = 0;
+		read_uptime(&(uptime0[curr]));
+		if (!uptime0[curr])
+			/* Cannot read system uptime (/proc/uptime doesn't exist) */
+			exit(2);
+
 		/* Read NFS directories stats */
 		read_nfs_stat(curr);
 
